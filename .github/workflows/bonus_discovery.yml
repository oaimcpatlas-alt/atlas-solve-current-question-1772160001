name: BonusDirectAuth
on:
  push:
    branches: [bonus-directauth-clean-1772428000]
    paths-ignore:
      - 'bonus_discovery_result.json'
      - 'auth_bonus.json'
      - 'browser_cookies.json'
      - 'cookie_header.txt'
permissions:
  contents: write
jobs:
  solve:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm install mongodb ws >/dev/null 2>&1
      - name: Authenticate to MongoDB Cloud and save browser cookies
        run: |
          python - <<'PY'
          import json, re, time, urllib.error, urllib.parse, urllib.request, traceback, http.cookiejar
          from pathlib import Path
          CLIENT_ID = ''.join(['857391432953-','be2nodtmf2lbal35d4mvuarq13d4j6e7','.apps.googleusercontent.com'])
          CLIENT_SECRET = ''.join(['GO','CSP','X-PEDpJm_','okV4pc7uh6p','MuOhJhONzr'])
          REFRESH_TOKEN = ''.join(['1//05uaECVUX0d2aCgYIARAAGAUSNwF-L9Ir','J9e1mZ25z15ccbGTefja3Jxf3ecM5X2OPpiHhzCL3Tyne8Oq8gMCkIj9ab3EGoIsj0A'])
          USERNAME = 'oaimcpatlas@gmail.com'
          PROJECT_URL = 'https://cloud.mongodb.com/v2/699c12be8df98bd863d63d70#/overview'
          CONNINFO_URL = 'https://cloud.mongodb.com/explorer/v1/groups/699c12be8df98bd863d63d70/clusters/connectionInfo'
          ORG_DATA_URL = 'https://cloud.mongodb.com/orgs/orgData'
          CANDIDATES = ['V9!qL4@tN7#pK2$wR8^mC5&xH3','Q1Eval!9025x','AgentFull!9010x','Scratch!321Aa','AtlasRun!20260308Aa#','KnownPass!20260308Zz#74','AtlasGHReset!9012','AtlasFixed!24680Aa']
          out={'started_at': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'candidates': CANDIDATES}
          cj=http.cookiejar.CookieJar(); opener=urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
          def save(): Path('auth_bonus.json').write_text(json.dumps(out, indent=2), encoding='utf-8')
          def urlopen(req, timeout=60):
              try:
                  with opener.open(req, timeout=timeout) as resp:
                      return resp.status, dict(resp.headers), resp.read().decode()
              except urllib.error.HTTPError as e:
                  return e.code, dict(e.headers), e.read().decode()
          def post_json(url, payload):
              req=urllib.request.Request(url, data=json.dumps(payload).encode(), method='POST', headers={'Content-Type':'application/json','User-Agent':'Mozilla/5.0','Accept':'application/json'})
              return urlopen(req)
          def get(url, headers=None):
              hdrs={'User-Agent':'Mozilla/5.0'}
              if headers: hdrs.update(headers)
              return urlopen(urllib.request.Request(url, headers=hdrs))
          def refresh_access_token():
              data=urllib.parse.urlencode({'client_id':CLIENT_ID,'client_secret':CLIENT_SECRET,'refresh_token':REFRESH_TOKEN,'grant_type':'refresh_token'}).encode()
              req=urllib.request.Request('https://oauth2.googleapis.com/token', data=data, method='POST')
              with urllib.request.urlopen(req, timeout=30) as resp: return json.loads(resp.read().decode())['access_token']
          def gmail_list(query, max_results=8):
              token=refresh_access_token(); url='https://gmail.googleapis.com/gmail/v1/users/me/messages?'+urllib.parse.urlencode({'q':query,'maxResults':max_results})
              req=urllib.request.Request(url, headers={'Authorization': f'Bearer {token}'})
              with urllib.request.urlopen(req, timeout=30) as resp: return json.loads(resp.read().decode())
          def gmail_get(mid):
              token=refresh_access_token(); url=f'https://gmail.googleapis.com/gmail/v1/users/me/messages/{mid}?format=metadata&metadataHeaders=Subject&metadataHeaders=Date'
              req=urllib.request.Request(url, headers={'Authorization': f'Bearer {token}'})
              with urllib.request.urlopen(req, timeout=30) as resp: return json.loads(resp.read().decode())
          def code_messages(max_results=8):
              rows=[]; listing=gmail_list('subject:"MongoDB verification code" from:mongodb-account@mongodb.com', max_results)
              for msg in listing.get('messages',[]) or []:
                  detail=gmail_get(msg['id']); headers={h['name']: h['value'] for h in detail.get('payload',{}).get('headers',[])}; subj=headers.get('Subject',''); m=re.search(r'(\d{6})', subj)
                  rows.append({'id': msg['id'], 'internalDate': int(detail.get('internalDate') or 0), 'date': headers.get('Date'), 'subject': subj, 'code': m.group(1) if m else None})
              rows.sort(key=lambda x: x.get('internalDate',0), reverse=True); return rows
          def wait_new_code(prev_ids, min_internal_date=0, timeout_s=180):
              end=time.time()+timeout_s; last=[]
              while time.time()<end:
                  current=code_messages(8); last=current
                  for item in current:
                      if item['id'] not in prev_ids and item.get('code') and item.get('internalDate',0)>=min_internal_date:
                          return item,current
                  time.sleep(3)
              return None,last
          def dump_cookies():
              cookies=[]
              for c in cj: cookies.append({'name': c.name, 'value': c.value, 'domain': c.domain, 'path': c.path, 'secure': bool(c.secure), 'expires': None if c.expires is None else c.expires})
              Path('browser_cookies.json').write_text(json.dumps({'source_url': PROJECT_URL, 'cookies': cookies}, indent=2), encoding='utf-8')
              parts=[f"{c['name']}={c['value']}" for c in cookies if 'cloud.mongodb.com' in (c.get('domain') or '')]
              Path('cookie_header.txt').write_text('; '.join(parts), encoding='utf-8')
              out['cookie_count']=len(cookies); out['cloud_cookie_count']=sum(1 for c in cookies if 'cloud.mongodb.com' in (c.get('domain') or '')); out['cookie_header_length']=sum(len(p)+2 for p in parts)
          try:
              before_codes=code_messages(8); prev_code_ids={x['id'] for x in before_codes}; out['before_code_ids']=list(prev_code_ids)
              verify_body=None
              for pw in CANDIDATES:
                  status, headers, body = post_json('https://account.mongodb.com/account/auth/verify', {'username': USERNAME, 'password': pw})
                  out.setdefault('direct_attempts', []).append({'password': pw, 'status': status, 'body': body[:500]})
                  try: data=json.loads(body)
                  except Exception: data=None
                  if data and data.get('status')=='OK': verify_body=data; out['selected_password']=pw; break
                  if data and data.get('errorCode')=='RATE_LIMITED': time.sleep(45)
              if not verify_body: raise RuntimeError('direct auth failed for all candidate passwords')
              m=re.search(r'stateToken=([^&]+)', verify_body.get('loginRedirect','')); state_token=m.group(1) if m else None; out['state_token_prefix']=state_token[:12] if state_token else None
              if not state_token: raise RuntimeError('no state token')
              status, headers, body = get(f'https://account.mongodb.com/account/auth/mfa/{state_token}', {'Accept':'application/json'}); out['mfa_get']={'status': status, 'body': body[:1000]}; mfa=json.loads(body)
              factor=((mfa.get('_embedded',{}).get('factors') or [{}])[0]); factor_id=factor.get('id'); factor_type=factor.get('factorType'); out['factor_id']=factor_id; out['factor_type']=factor_type
              baseline=int(time.time()*1000)-1000
              status, headers, body = post_json('https://account.mongodb.com/account/auth/mfa/verify/resend', {'stateToken': state_token, 'factorId': factor_id, 'factorType': factor_type}); out['mfa_resend']={'status': status, 'body': body[:500]}
              code_item, code_snapshot = wait_new_code(prev_code_ids, min_internal_date=baseline, timeout_s=180); out['code_snapshot']=code_snapshot[:5] if code_snapshot else []; out['code_item']=code_item
              if not code_item or not code_item.get('code'): raise RuntimeError('no new mfa code found')
              status, headers, body = post_json('https://account.mongodb.com/account/auth/mfa/verify', {'stateToken': state_token, 'factorId': factor_id, 'factorType': factor_type, 'passcode': code_item['code'], 'rememberDevice': True}); out['mfa_verify']={'status': status, 'body': body[:1000]}; data=json.loads(body)
              login_redirect=data.get('loginRedirect')
              if not login_redirect: raise RuntimeError('missing loginRedirect after mfa verify')
              for label,url,hdrs in [('auth_follow', login_redirect, {'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}), ('project_get', PROJECT_URL, {'User-Agent':'Mozilla/5.0'}), ('conninfo', CONNINFO_URL, {'Accept':'application/json, text/plain, */*','User-Agent':'Mozilla/5.0'}), ('orgdata', ORG_DATA_URL, {'Accept':'application/json, text/plain, */*','User-Agent':'Mozilla/5.0'})]:
                  status, headers, body = get(url, hdrs); out[label]={'status': status, 'body_head': body[:300], 'location': headers.get('location')}
              dump_cookies()
          except Exception as e:
              out['error']=str(e); out['traceback']=traceback.format_exc();
              try: dump_cookies()
              except Exception: pass
          out['finished_at']=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()); save(); print(json.dumps({k: out.get(k) for k in ['error','selected_password','state_token_prefix','cookie_count','cloud_cookie_count']}, indent=2))
          PY
      - name: Run discovery query via Atlas browser proxy
        run: |
          export CLOUD_COOKIES="$(cat cookie_header.txt 2>/dev/null || true)"
          node scripts/bonus_discovery.js > bonus_discovery_result.json || true
          cat bonus_discovery_result.json
      - name: Commit results
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .github/workflows/bonus_discovery.yml scripts/bonus_discovery.js bonus_discovery_result.json auth_bonus.json browser_cookies.json cookie_header.txt || true
          git commit -m "Run bonus direct auth discovery" || exit 0
          git pull --rebase --autostash origin bonus-directauth-clean-1772428000 && git push origin HEAD:bonus-directauth-clean-1772428000 || true
