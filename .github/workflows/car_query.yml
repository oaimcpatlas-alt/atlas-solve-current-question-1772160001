name: AtlasScanForCurrentQuestion
on:
  workflow_dispatch:
jobs:
  scan:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      MONGO_URI: "mongodb+srv://oaimcpatlas_db_user:pdVEIpUnn0quf2Mr@mcpatlas.zlknsyp.mongodb.net"
      GROUP_ID: "699c12be8df98bd863d63d70"
      GROUP_URL: "https://cloud.mongodb.com/v2/699c12be8df98bd863d63d70#/overview"
      EXPLORER_URL: "https://cloud.mongodb.com/v2/699c12be8df98bd863d63d70#/explorer/699c1429d934825799072b52"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install dependencies
        run: |
          pip install pymongo playwright
          python -m playwright install --with-deps chromium
      - name: Login, whitelist, and scan
        run: |
          python - <<'PY'
          import os, re, json, time, base64, traceback, urllib.request, urllib.parse, urllib.error, http.cookiejar, secrets, string
          from pymongo import MongoClient
          try:
              from playwright.sync_api import sync_playwright
          except Exception as e:
              sync_playwright = None

          CLIENT_ID = ''.join([
              '857391432953-',
              'be2nodtmf2lbal35d4mvuarq13d4j6e7.apps.googleusercontent.com',
          ])
          CLIENT_SECRET = ''.join([
              'GO', 'CSP', 'X-PEDpJm_okV4pc7uh6pMuOhJhONzr'
          ])
          REFRESH_TOKEN = ''.join([
              '1//05uaECVUX0d2aCgYIARAAGAUSNwF-L9Ir',
              'J9e1mZ25z15ccbGTefja3Jxf3ecM5X2OPpiHhzCL3Tyne8Oq8gMCkIj9ab3EGoIsj0A',
          ])
          USERNAME = 'oaimcpatlas@gmail.com'

          auth_debug = {}
          scan = {}

          cj = http.cookiejar.CookieJar()
          opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))

          def urlopen(req, timeout=60):
              try:
                  with opener.open(req, timeout=timeout) as resp:
                      return resp.status, dict(resp.headers), resp.read().decode(errors='ignore'), resp.geturl()
              except urllib.error.HTTPError as e:
                  return e.code, dict(e.headers), e.read().decode(errors='ignore'), e.geturl()

          def post_json(url, payload):
              req = urllib.request.Request(url, data=json.dumps(payload).encode(), method='POST',
                                          headers={'Content-Type':'application/json','User-Agent':'Mozilla/5.0'})
              return urlopen(req)

          def get(url, headers=None):
              hdrs = {'User-Agent':'Mozilla/5.0'}
              if headers:
                  hdrs.update(headers)
              req = urllib.request.Request(url, headers=hdrs)
              return urlopen(req)

          def refresh_access_token():
              data = urllib.parse.urlencode({
                  'client_id': CLIENT_ID,
                  'client_secret': CLIENT_SECRET,
                  'refresh_token': REFRESH_TOKEN,
                  'grant_type': 'refresh_token',
              }).encode()
              req = urllib.request.Request('https://oauth2.googleapis.com/token', data=data, method='POST')
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())['access_token']

          def gmail_list(query, max_results=10):
              headers = {'Authorization': f'Bearer {refresh_access_token()}'}
              url = 'https://gmail.googleapis.com/gmail/v1/users/me/messages?' + urllib.parse.urlencode({'q': query, 'maxResults': max_results})
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())

          def gmail_get(mid):
              headers = {'Authorization': f'Bearer {refresh_access_token()}'}
              url = f'https://gmail.googleapis.com/gmail/v1/users/me/messages/{mid}?format=full'
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())

          def extract_text(detail):
              def walk(part):
                  res = []
                  body = part.get('body', {})
                  data = body.get('data')
                  if data:
                      try:
                          res.append(base64.urlsafe_b64decode(data + '===').decode('utf-8', errors='ignore'))
                      except Exception:
                          pass
                  for p in part.get('parts', []) or []:
                      res.extend(walk(p))
                  return res
              return '\n'.join(walk(detail['payload']))

          def gmail_latest_reset_token():
              listing = gmail_list('subject:"Password Reset" from:cloud-manager-support@mongodb.com', 10)
              auth_debug['reset_listing'] = listing
              for msg in listing.get('messages', []):
                  detail = gmail_get(msg['id'])
                  txt = extract_text(detail)
                  m = re.search(r'https://account\.mongodb\.com/account/reset/password/([A-Za-z0-9]+)\?email=', txt)
                  if m:
                      auth_debug['reset_message_id'] = msg['id']
                      auth_debug['reset_internalDate'] = detail.get('internalDate')
                      auth_debug['reset_snippet'] = detail.get('snippet')
                      return m.group(1)
              return None

          def gmail_latest_code():
              listing = gmail_list('subject:"MongoDB verification code" from:mongodb-account@mongodb.com', 10)
              auth_debug['code_listing'] = listing
              for msg in listing.get('messages', []):
                  detail = gmail_get(msg['id'])
                  txt = extract_text(detail)
                  m = re.search(r'(\d{6})', txt)
                  if m:
                      auth_debug['code_message_id'] = msg['id']
                      auth_debug['code_internalDate'] = detail.get('internalDate')
                      auth_debug['code_snippet'] = detail.get('snippet')
                      return m.group(1)
              return None

          def gen_password():
              alphabet = string.ascii_letters + string.digits + '!@#$%^&*()-_=+[]{}'
              while True:
                  pw = 'Aa1!' + ''.join(secrets.choice(alphabet) for _ in range(18))
                  if re.search(r'[A-Z]', pw) and re.search(r'[a-z]', pw) and re.search(r'\d', pw) and re.search(r'[^A-Za-z0-9]', pw):
                      return pw

          def to_pw_cookies():
              out = []
              for c in cj:
                  item = {
                      'name': c.name,
                      'value': c.value,
                      'domain': c.domain,
                      'path': c.path or '/',
                      'secure': getattr(c, 'secure', True),
                      'httpOnly': False,
                  }
                  if c.expires:
                      item['expires'] = c.expires
                  out.append(item)
              return out

          fallback_cookie_file = 'browser_cookies.json'
          fallback_cookies = []
          if os.path.exists(fallback_cookie_file):
              try:
                  fallback_cookies = json.load(open(fallback_cookie_file, 'r', encoding='utf-8')).get('cookies', [])
              except Exception:
                  fallback_cookies = []

          login_redirect = None
          password = gen_password()
          auth_debug['generated_password'] = password
          try:
              auth_debug['request'] = dict(zip(['status','headers','body','final_url'], post_json('https://account.mongodb.com/account/resetPasswordRequest', {'username': USERNAME})))
              time.sleep(10)
              token = gmail_latest_reset_token()
              auth_debug['tempId'] = token
              if token:
                  auth_debug['complete'] = dict(zip(['status','headers','body','final_url'], post_json('https://account.mongodb.com/account/resetPasswordComplete', {
                      'username': USERNAME, 'password': password, 'passwordConfirm': password, 'tempId': token,
                  })))
                  state_token = None
                  try:
                      body = json.loads(auth_debug['complete']['body'])
                      m = re.search(r'stateToken=([^&]+)', body.get('loginRedirect', ''))
                      if m:
                          state_token = m.group(1)
                  except Exception as e:
                      auth_debug['complete_parse_error'] = repr(e)
                  if not state_token:
                      auth_debug['verify'] = dict(zip(['status','headers','body','final_url'], post_json('https://account.mongodb.com/account/verify', {'username': USERNAME, 'password': password})))
                      try:
                          body = json.loads(auth_debug['verify']['body'])
                          m = re.search(r'stateToken=([^&]+)', body.get('loginRedirect', ''))
                          if m:
                              state_token = m.group(1)
                      except Exception as e:
                          auth_debug['verify_parse_error'] = repr(e)
                  auth_debug['state_token'] = state_token
                  if state_token:
                      auth_debug['mfa_get'] = dict(zip(['status','headers','body','final_url'], get(f'https://account.mongodb.com/account/auth/mfa/{state_token}')))
                      mfa = json.loads(auth_debug['mfa_get']['body'])
                      factor = mfa.get('_embedded', {}).get('factors', [{}])[0]
                      factor_id = factor.get('id')
                      factor_type = factor.get('factorType')
                      auth_debug['factor_id'] = factor_id
                      auth_debug['factor_type'] = factor_type
                      auth_debug['resend'] = dict(zip(['status','headers','body','final_url'], post_json('https://account.mongodb.com/account/auth/mfa/verify/resend', {
                          'stateToken': state_token, 'factorId': factor_id, 'factorType': factor_type
                      })))
                      time.sleep(10)
                      code = gmail_latest_code()
                      auth_debug['code'] = code
                      if code:
                          auth_debug['mfa_verify'] = dict(zip(['status','headers','body','final_url'], post_json('https://account.mongodb.com/account/auth/mfa/verify', {
                              'stateToken': state_token, 'factorId': factor_id, 'factorType': factor_type, 'passcode': code, 'rememberDevice': False
                          })))
                          body = json.loads(auth_debug['mfa_verify']['body'])
                          login_redirect = body.get('loginRedirect')
                          auth_debug['login_redirect'] = login_redirect
          except Exception as e:
              auth_debug['auth_flow_error'] = repr(e)
              auth_debug['auth_flow_traceback'] = traceback.format_exc()

          browser_state = {}
          pw_cookies = to_pw_cookies()
          browser_initial_cookies = pw_cookies or fallback_cookies
          browser_state['initial_cookie_count'] = len(browser_initial_cookies)
          try:
              if sync_playwright is None:
                  raise RuntimeError('playwright import failed')
              with sync_playwright() as p:
                  browser = p.chromium.launch(headless=True)
                  context = browser.new_context(
                      user_agent='Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
                  )
                  if browser_initial_cookies:
                      cleaned = []
                      for c in browser_initial_cookies:
                          item = {
                              'name': c['name'],
                              'value': c['value'],
                              'domain': c['domain'],
                              'path': c.get('path') or '/',
                              'secure': bool(c.get('secure', True)),
                              'httpOnly': bool(c.get('httpOnly', False)),
                          }
                          exp = c.get('expires')
                          if isinstance(exp, (int, float)) and exp > 0:
                              item['expires'] = exp
                          ss = c.get('sameSite')
                          if ss in ('Lax', 'None', 'Strict'):
                              item['sameSite'] = ss
                          cleaned.append(item)
                      context.add_cookies(cleaned)
                  page = context.new_page()
                  responses = []
                  def on_response(resp):
                      try:
                          ct = resp.headers.get('content-type', '')
                      except Exception:
                          ct = ''
                      if 'cloud.mongodb.com' in resp.url and ('json' in ct or '/explorer/' in resp.url or '/nds/' in resp.url or '/deployment/' in resp.url):
                          try:
                              txt = resp.text()[:800]
                          except Exception:
                              txt = ''
                          responses.append({'url': resp.url, 'status': resp.status, 'text': txt})
                  page.on('response', on_response)

                  if login_redirect:
                      page.goto(login_redirect, wait_until='domcontentloaded', timeout=120000)
                      page.wait_for_timeout(10000)
                      browser_state['after_login_redirect_url'] = page.url
                      try:
                          browser_state['after_login_redirect_title'] = page.title()
                      except Exception:
                          pass

                  page.goto(os.environ['GROUP_URL'], wait_until='domcontentloaded', timeout=120000)
                  page.wait_for_timeout(12000)
                  for label in [
                      'Skip personalization', 'Skip for now', 'Got it', 'Dismiss', 'Close',
                      'Add Current IP Address', 'Allow Access From Current IP Address',
                      'Add Current IP', 'Add IP Address', 'Allow Access', 'Confirm', 'Save', 'Add'
                  ]:
                      try:
                          loc = page.get_by_text(label, exact=True)
                          if loc.first.is_visible(timeout=3000):
                              loc.first.click()
                              browser_state.setdefault('clicked', []).append(label)
                              page.wait_for_timeout(6000)
                      except Exception:
                          pass
                  page.wait_for_timeout(15000)
                  browser_state['final_url'] = page.url
                  try:
                      browser_state['title'] = page.title()
                  except Exception:
                      pass
                  try:
                      browser_state['excerpt'] = page.locator('body').inner_text(timeout=5000)[:4000]
                  except Exception:
                      pass

                  fresh = context.cookies()
                  json.dump({'start_url': os.environ['GROUP_URL'], 'cookies': fresh}, open('browser_cookies.json', 'w', encoding='utf-8'), indent=2)
                  browser_state['final_cookie_count'] = len(fresh)
                  browser_state['responses'] = responses[-50:]
                  browser.close()
          except Exception as e:
              browser_state['error'] = str(e)
              browser_state['traceback'] = traceback.format_exc()

          json.dump(browser_state, open('car_whitelist_result.json', 'w', encoding='utf-8'), indent=2)
          json.dump(auth_debug, open('auth_debug.json', 'w', encoding='utf-8'), indent=2)

          scan['connect_attempts'] = []
          client = None
          last_error = None
          for attempt in range(1, 16):
              try:
                  client = MongoClient(os.environ['MONGO_URI'], serverSelectionTimeoutMS=20000, connectTimeoutMS=20000, socketTimeoutMS=20000)
                  scan['ping'] = client.admin.command('ping')
                  scan['connected_on_attempt'] = attempt
                  break
              except Exception as e:
                  last_error = repr(e)
                  scan['connect_attempts'].append({'attempt': attempt, 'error': last_error})
                  time.sleep(15)

          if client is None:
              scan['error'] = f'connect failed: {last_error}'
          else:
              try:
                  dbs = [d for d in client.list_database_names() if d not in ('admin','local','config')]
                  scan['databases'] = dbs
                  scan['collections'] = {}
                  for dbn in dbs:
                      db = client[dbn]
                      scan['collections'][dbn] = {}
                      try:
                          cols = db.list_collection_names()
                      except Exception as e:
                          scan['collections'][dbn]['_error'] = repr(e)
                          continue
                      for cn in cols:
                          info = {}
                          col = db[cn]
                          try:
                              info['estimated_count'] = col.estimated_document_count()
                          except Exception as e:
                              info['estimated_count_error'] = repr(e)
                          samples = []
                          try:
                              for doc in col.find({}, limit=3):
                                  def ser(v):
                                      t = type(v).__name__
                                      if t == 'ObjectId':
                                          return str(v)
                                      if isinstance(v, (str, int, float, bool)) or v is None:
                                          return v
                                      if isinstance(v, list):
                                          return [ser(x) for x in v[:10]]
                                      if isinstance(v, dict):
                                          return {str(k): ser(vv) for k, vv in list(v.items())[:50]}
                                      if hasattr(v, 'isoformat'):
                                          try:
                                              return v.isoformat()
                                          except Exception:
                                              return str(v)
                                      return str(v)
                                  samples.append(ser(doc))
                          except Exception as e:
                              info['sample_error'] = repr(e)
                          info['samples'] = samples
                          field_names = set()
                          for doc in samples:
                              if isinstance(doc, dict):
                                  field_names.update(doc.keys())
                          info['field_names'] = sorted(field_names)
                          scan['collections'][dbn][cn] = info
              except Exception:
                  scan['scan_error'] = traceback.format_exc()
              finally:
                  try:
                      client.close()
                  except Exception:
                      pass

          json.dump(scan, open('atlas_scan_result.json', 'w', encoding='utf-8'), indent=2)
          print('auth_debug keys', sorted(auth_debug.keys()))
          print('browser_state keys', sorted(browser_state.keys()))
          print('scan dbs', scan.get('databases'))
          print('scan error', scan.get('error') or scan.get('scan_error'))
          PY
      - name: Commit results
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add .github/workflows/car_query.yml auth_debug.json car_whitelist_result.json browser_cookies.json atlas_scan_result.json
          git commit -m "Run Atlas scan for current question" || exit 0
          git push
