name: answer-shipping-ups
on:
  push:
    branches: [main]
    paths:
      - '.github/workflows/answer_shipping_ups.yml'
      - 'scripts/answer_shipping_ups.js'

jobs:
  solve:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GROUP_URL: "https://cloud.mongodb.com/v2/699c12be8df98bd863d63d70#/overview"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: |
          pip install playwright
          python -m playwright install --with-deps chromium
          npm init -y >/dev/null 2>&1 || true
          npm install ws mongodb >/dev/null 2>&1
      - name: Authenticate via API, finalize cookies, and capture session
        run: |
          mkdir -p outputs
          python - <<'PY'
          import base64, http.cookiejar, json, os, re, time, traceback, urllib.parse, urllib.request, urllib.error
          from playwright.sync_api import sync_playwright

          CLIENT_ID = ''.join([
              '857391432953-',
              'be2nodtmf2lbal35d4mvuarq13d4j6e7.apps.googleusercontent.com',
          ])
          CLIENT_SECRET = ''.join([
              'GO', 'CSP', 'X-PEDpJm_okV4pc7uh6pMuOhJhONzr'
          ])
          REFRESH_TOKEN = ''.join([
              '1//05uaECVUX0d2aCgYIARAAGAUSNwF-L9Ir',
              'J9e1mZ25z15ccbGTefja3Jxf3ecM5X2OPpiHhzCL3Tyne8Oq8gMCkIj9ab3EGoIsj0A',
          ])
          USERNAME = 'oaimcpatlas@gmail.com'
          PASSWORD = ''.join(['AtlasGHReset', '!9012'])

          summary = {}
          cookie_header = ''
          cj = http.cookiejar.CookieJar()
          opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))

          def urlopen(req, timeout=60):
              try:
                  with opener.open(req, timeout=timeout) as resp:
                      return resp.status, dict(resp.headers), resp.read().decode()
              except urllib.error.HTTPError as e:
                  return e.code, dict(e.headers), e.read().decode()

          def post_json(url, payload):
              req = urllib.request.Request(
                  url,
                  data=json.dumps(payload).encode(),
                  method='POST',
                  headers={'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0', 'Accept': 'application/json'},
              )
              return urlopen(req)

          def refresh_access_token():
              data = urllib.parse.urlencode({
                  'client_id': CLIENT_ID,
                  'client_secret': CLIENT_SECRET,
                  'refresh_token': REFRESH_TOKEN,
                  'grant_type': 'refresh_token',
              }).encode()
              req = urllib.request.Request('https://oauth2.googleapis.com/token', data=data, method='POST')
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())['access_token']

          def gmail_list(query, max_results=8):
              headers = {'Authorization': f'Bearer {refresh_access_token()}'}
              url = 'https://gmail.googleapis.com/gmail/v1/users/me/messages?' + urllib.parse.urlencode({'q': query, 'maxResults': max_results})
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())

          def gmail_get(mid):
              headers = {'Authorization': f'Bearer {refresh_access_token()}'}
              url = f'https://gmail.googleapis.com/gmail/v1/users/me/messages/{mid}?format=full'
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode())

          def extract_text(detail):
              def walk(part):
                  out = []
                  body = part.get('body', {})
                  d = body.get('data')
                  if d:
                      out.append(base64.urlsafe_b64decode(d + '===').decode('utf-8', errors='ignore'))
                  for p in part.get('parts', []) or []:
                      out.extend(walk(p))
                  return out
              return '\n'.join(walk(detail['payload']))

          def code_messages():
              listing = gmail_list('subject:"MongoDB verification code" from:mongodb-account@mongodb.com', 8)
              out = []
              for msg in listing.get('messages', []) or []:
                  detail = gmail_get(msg['id'])
                  txt = extract_text(detail)
                  m = re.search(r'(\d{6})', txt)
                  out.append({
                      'id': msg['id'],
                      'internalDate': detail.get('internalDate'),
                      'snippet': detail.get('snippet'),
                      'code': m.group(1) if m else None,
                  })
              return out

          def latest_reset_tokens(max_results=8):
              listing = gmail_list('subject:"Password Reset" from:cloud-manager-support@mongodb.com', max_results)
              out = []
              for msg in listing.get('messages', []) or []:
                  detail = gmail_get(msg['id'])
                  txt = extract_text(detail)
                  m = re.search(r'https://account\.mongodb\.com/account/reset/password/([A-Za-z0-9]+)\?email=', txt)
                  if m:
                      out.append({
                          'id': msg['id'],
                          'internalDate': detail.get('internalDate'),
                          'token': m.group(1),
                      })
              return out

          def wait_new_code(prev_ids, timeout_s=60):
              end = time.time() + timeout_s
              last = None
              while time.time() < end:
                  current = code_messages()
                  if current:
                      last = current[0]
                  for item in current:
                      if item['id'] not in prev_ids and item.get('code'):
                          return item
                  time.sleep(3)
              return last if last and last.get('code') else None

          def jar_cookies():
              return [
                  {
                      'name': c.name,
                      'value': c.value,
                      'domain': c.domain,
                      'path': c.path,
                      'secure': bool(c.secure),
                      'expires': None if c.expires is None else c.expires,
                  }
                  for c in cj
              ]

          def build_cookie_header(cookies):
              parts = [f"{c['name']}={c['value']}" for c in cookies if 'cloud.mongodb.com' in c.get('domain', '')]
              return '; '.join(parts)

          def try_session_token_bootstrap():
              try:
                  login_url = None
                  seed_cookies = []
                  if os.path.exists('session_token_probe_result.json'):
                      data = json.load(open('session_token_probe_result.json', 'r', encoding='utf-8'))
                      login_url = data.get('loginUrl')
                  if os.path.exists('session_token_probe.js'):
                      src = open('session_token_probe.js', 'r', encoding='utf-8').read()
                      m = re.search(r'const seedCookies = (\[.*?\]);', src, re.S)
                      if m:
                          seed_cookies = json.loads(m.group(1))
                  if os.path.exists('browser_cookies.json'):
                      raw = json.load(open('browser_cookies.json', 'r', encoding='utf-8'))
                      for c in raw.get('cookies', []):
                          if c.get('name') in ('remember-user-device', 'user-device'):
                              seed_cookies.append({
                                  'name': c['name'],
                                  'value': c['value'],
                                  'domain': c['domain'],
                                  'path': c.get('path') or '/',
                              })
                  summary['session_token_login_url_present'] = bool(login_url)
                  summary['session_token_seed_cookie_count'] = len(seed_cookies)
                  if not login_url:
                      return ''
                  with sync_playwright() as p:
                      browser = p.chromium.launch(headless=True)
                      context = browser.new_context(
                          user_agent='Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
                      )
                      if seed_cookies:
                          context.add_cookies([
                              {
                                  'name': c['name'],
                                  'value': c['value'],
                                  'domain': c['domain'],
                                  'path': c.get('path') or '/',
                                  'secure': True,
                              }
                              for c in seed_cookies
                          ])
                      page = context.new_page()
                      page.goto(login_url, wait_until='domcontentloaded', timeout=120000)
                      page.wait_for_timeout(12000)
                      summary['session_token_after_login_url'] = page.url
                      summary['session_token_after_login_title'] = page.title()
                      try:
                          summary['session_token_after_login_text'] = page.locator('body').inner_text(timeout=5000)[:4000]
                      except Exception:
                          pass
                      page.goto(os.environ['GROUP_URL'], wait_until='domcontentloaded', timeout=120000)
                      page.wait_for_timeout(12000)
                      summary['session_token_after_group_url'] = page.url
                      summary['session_token_after_group_title'] = page.title()
                      try:
                          summary['session_token_after_group_text'] = page.locator('body').inner_text(timeout=5000)[:4000]
                      except Exception:
                          pass
                      browser_cookies = context.cookies()
                      header = '; '.join(
                          f"{c.get('name')}={c.get('value')}"
                          for c in browser_cookies
                          if 'cloud.mongodb.com' in c.get('domain', '')
                      )
                      summary['session_token_cloud_cookie_names'] = [
                          c.get('name') for c in browser_cookies if 'cloud.mongodb.com' in c.get('domain', '')
                      ]
                      if header:
                          with open('outputs/answer_shipping_cookies.json', 'w', encoding='utf-8') as f:
                              json.dump({'cookies': browser_cookies}, f, indent=2)
                      browser.close()
                      return header
              except Exception as e:
                  summary['session_token_error'] = repr(e)
                  summary['session_token_traceback'] = traceback.format_exc()
                  return ''

          try:
              before = code_messages()
              before_ids = {m['id'] for m in before}
              summary['before_code_ids'] = list(before_ids)[:5]

              cookie_header = try_session_token_bootstrap()
              summary['cloud_cookie_header_present_after_session_token'] = bool(cookie_header)
              if cookie_header:
                  summary['cloud_cookie_header_present_final'] = True
                  raise SystemExit

              # First try direct verify; if rate-limited, fall back to completing a recent reset token.
              verify_rec = None
              verify_body = None
              auth_method = None

              for attempt in range(1, 3):
                  status, headers, body = post_json('https://account.mongodb.com/account/auth/verify', {
                      'username': USERNAME,
                      'password': PASSWORD,
                  })
                  verify_rec = {'status': status, 'headers': headers, 'body': body[:4000], 'attempt': attempt}
                  summary['verify'] = verify_rec
                  try:
                      verify_body = json.loads(body)
                  except Exception:
                      verify_body = None
                  if verify_body and verify_body.get('status') == 'OK':
                      auth_method = 'verify'
                      break
                  if verify_body and verify_body.get('errorCode') == 'RATE_LIMITED':
                      time.sleep(15)
                      continue
                  break

              if not auth_method:
                  reset_candidates = latest_reset_tokens(8)
                  summary['reset_candidates'] = [{'id': x['id'], 'internalDate': x['internalDate']} for x in reset_candidates[:8]]
                  reset_password = 'AtlasRun!' + str(int(time.time())) + 'Q#7m'
                  summary['reset_password_suffix'] = reset_password[-6:]
                  for cand in reset_candidates:
                      status, headers, body = post_json('https://account.mongodb.com/account/resetPasswordComplete', {
                          'username': USERNAME,
                          'password': reset_password,
                          'passwordConfirm': reset_password,
                          'tempId': cand['token'],
                      })
                      rec = {'id': cand['id'], 'status': status, 'headers': headers, 'body': body[:4000]}
                      summary.setdefault('reset_attempts', []).append(rec)
                      try:
                          data = json.loads(body)
                      except Exception:
                          data = None
                      if data and data.get('status') == 'OK':
                          verify_body = data
                          auth_method = 'resetPasswordComplete'
                          summary['reset_success_id'] = cand['id']
                          break
                      if data and data.get('errorCode') == 'RATE_LIMITED':
                          break

              summary['auth_method'] = auth_method
              if not verify_body or verify_body.get('status') != 'OK':
                  raise RuntimeError(f"auth bootstrap failed: {verify_rec}")

              login_redirect = verify_body.get('loginRedirect')
              m = re.search(r'stateToken=([^&]+)', login_redirect or '')
              state_token = m.group(1) if m else None
              summary['state_token_prefix'] = state_token[:12] if state_token else None
              if not state_token:
                  raise RuntimeError('no state token')

              status, headers, body = urlopen(urllib.request.Request(
                  f'https://account.mongodb.com/account/auth/mfa/{state_token}',
                  headers={'User-Agent': 'Mozilla/5.0', 'Accept': 'application/json'}
              ))
              summary['mfa_get'] = {'status': status, 'body': body[:4000]}
              mfa_data = json.loads(body)
              factor = (mfa_data.get('_embedded', {}).get('factors') or [{}])[0]
              factor_id = factor.get('id')
              factor_type = factor.get('factorType')
              summary['factor_id'] = factor_id
              summary['factor_type'] = factor_type
              if not factor_id or not factor_type:
                  raise RuntimeError('no MFA factor')

              code_item = wait_new_code(before_ids, timeout_s=20)
              if not code_item:
                  status, headers, body = post_json('https://account.mongodb.com/account/auth/mfa/verify/resend', {
                      'stateToken': state_token,
                      'factorId': factor_id,
                      'factorType': factor_type,
                  })
                  summary['mfa_resend'] = {'status': status, 'body': body[:4000]}
                  code_item = wait_new_code(before_ids, timeout_s=60)

              summary['new_code_id'] = code_item['id'] if code_item else None
              if not code_item or not code_item.get('code'):
                  raise RuntimeError('no MFA code found')

              status, headers, body = post_json('https://account.mongodb.com/account/auth/mfa/verify', {
                  'stateToken': state_token,
                  'factorId': factor_id,
                  'factorType': factor_type,
                  'passcode': code_item['code'],
                  'rememberDevice': True,
              })
              summary['mfa_verify'] = {'status': status, 'body': body[:4000]}
              mfa_verify = json.loads(body)
              if mfa_verify.get('status') != 'OK':
                  raise RuntimeError(f'mfa verify failed: {mfa_verify}')
              final_login_redirect = mfa_verify.get('loginRedirect')
              summary['login_redirect_present'] = bool(final_login_redirect)

              if final_login_redirect:
                  req = urllib.request.Request(final_login_redirect, headers={'User-Agent': 'Mozilla/5.0'})
                  status, headers, body = urlopen(req, timeout=120)
                  summary['login_redirect_follow'] = {'status': status, 'location': headers.get('location'), 'body_snippet': body[:500]}
              req = urllib.request.Request(os.environ['GROUP_URL'], headers={'User-Agent': 'Mozilla/5.0'})
              status, headers, body = urlopen(req, timeout=120)
              summary['group_fetch'] = {'status': status, 'body_snippet': body[:500]}

              cookies = jar_cookies()
              cookie_header = build_cookie_header(cookies)
              summary['cookie_count_after_http'] = len(cookies)
              summary['cloud_cookie_names_after_http'] = [c['name'] for c in cookies if 'cloud.mongodb.com' in c.get('domain', '')]
              summary['cloud_cookie_header_present_after_http'] = bool(cookie_header)

              if not cookie_header and final_login_redirect:
                  with sync_playwright() as p:
                      browser = p.chromium.launch(headless=True)
                      context = browser.new_context(
                          user_agent='Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
                      )
                      context.add_cookies([
                          {
                              'name': c['name'],
                              'value': c['value'],
                              'domain': c['domain'],
                              'path': c.get('path') or '/',
                              'secure': bool(c.get('secure', True)),
                              **({'expires': c['expires']} if isinstance(c.get('expires'), (int, float)) and c['expires'] else {})
                          }
                          for c in cookies
                      ])
                      page = context.new_page()
                      page.goto(final_login_redirect, wait_until='domcontentloaded', timeout=120000)
                      page.wait_for_timeout(12000)
                      page.goto(os.environ['GROUP_URL'], wait_until='domcontentloaded', timeout=120000)
                      page.wait_for_timeout(12000)
                      browser_cookies = context.cookies()
                      summary['browser_after_url'] = page.url
                      summary['browser_after_title'] = page.title()
                      summary['browser_after_excerpt'] = page.locator('body').inner_text(timeout=5000)[:8000]
                      summary['browser_cookie_count'] = len(browser_cookies)
                      summary['cloud_cookie_names_after_browser'] = [
                          c.get('name') for c in browser_cookies if 'cloud.mongodb.com' in c.get('domain', '')
                      ]
                      cookie_header = '; '.join(
                          f"{c.get('name')}={c.get('value')}"
                          for c in browser_cookies
                          if 'cloud.mongodb.com' in c.get('domain', '')
                      )
                      with open('outputs/answer_shipping_cookies.json', 'w', encoding='utf-8') as f:
                          json.dump({'cookies': browser_cookies}, f, indent=2)
                      browser.close()

              summary['cloud_cookie_header_present_final'] = bool(cookie_header)
          except SystemExit:
              pass
          except Exception as e:
              summary['error'] = str(e)
              summary['traceback'] = traceback.format_exc()

          with open('outputs/answer_shipping_cookie_header.txt', 'w', encoding='utf-8') as f:
              f.write(cookie_header)
          with open('outputs/answer_shipping_auth.json', 'w', encoding='utf-8') as f:
              json.dump(summary, f, indent=2)

          print(json.dumps({
              'verify_status': (summary.get('verify') or {}).get('status'),
              'mfa_verify_status': (summary.get('mfa_verify') or {}).get('status'),
              'cloud_cookie_header_present_final': summary.get('cloud_cookie_header_present_final'),
              'error': summary.get('error'),
          }, indent=2))
          PY
      - name: Run proxy query
        run: |
          export CLOUD_COOKIES="$(cat outputs/answer_shipping_cookie_header.txt 2>/dev/null || true)"
          mkdir -p outputs
          if [ -z "$CLOUD_COOKIES" ]; then
            echo '{"error":"no cloud cookies from auth step"}' > outputs/answer_shipping_ups.json
          else
            node scripts/answer_shipping_ups.js > outputs/answer_shipping_ups.json || true
          fi
          cat outputs/answer_shipping_ups.json
      - name: Commit result
        if: always()
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add outputs/answer_shipping_ups.json outputs/answer_shipping_auth.json
          git commit -m "Refresh shipping UPS answer" || exit 0
          for i in 1 2 3 4 5 6; do
            git pull --rebase origin main && git push origin main && exit 0 || true
            sleep 10
          done
          exit 0
